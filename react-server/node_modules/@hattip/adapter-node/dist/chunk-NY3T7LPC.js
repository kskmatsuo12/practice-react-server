// src/common.ts
import { once } from "events";
import {
  createServer as createHttpServer
} from "http";
import { Readable } from "stream";
function createMiddleware(handler, options = {}) {
  const {
    origin = process.env.ORIGIN,
    trustProxy = process.env.TRUST_PROXY === "1",
    alwaysCallNext = true
  } = options;
  let { protocol, host } = origin ? new URL(origin) : {};
  if (protocol) {
    protocol = protocol.slice(0, -1);
  }
  return async (req, res, next) => {
    var _a, _b;
    function getForwardedHeader(name) {
      return (String(req.headers["x-forwarded-" + name]) || "").split(",", 1)[0].trim();
    }
    protocol = protocol || req.protocol || trustProxy && getForwardedHeader("proto") || ((_a = req.socket) == null ? void 0 : _a.encrypted) && "https" || "http";
    host = host || trustProxy && getForwardedHeader("host") || req.headers.host;
    if (!host) {
      console.warn(
        "Could not automatically determine the origin host, using 'localhost'. Use the 'origin' option or the 'ORIGIN' environment variable to set the origin explicitly."
      );
      host = "localhost";
    }
    const ip = req.ip || trustProxy && getForwardedHeader("for") || ((_b = req.socket) == null ? void 0 : _b.remoteAddress) || "";
    let headers = req.headers;
    if (headers[":method"]) {
      headers = Object.fromEntries(
        Object.entries(headers).filter(([key]) => !key.startsWith(":"))
      );
    }
    const request = new Request(protocol + "://" + host + req.url, {
      method: req.method,
      headers,
      body: req.method === "GET" || req.method === "HEAD" ? void 0 : req.socket ? req : (
        // Convert to a ReadableStream for Deno
        new ReadableStream({
          start(controller) {
            req.on("data", (chunk) => controller.enqueue(chunk));
            req.on("end", () => controller.close());
            req.on("error", (err) => controller.error(err));
          }
        })
      ),
      // @ts-expect-error: Node requires this for streams
      duplex: "half"
    });
    let passThroughCalled = false;
    const context = {
      request,
      ip,
      waitUntil(promise) {
      },
      passThrough() {
        passThroughCalled = true;
      },
      platform: {
        name: "node",
        request: req,
        response: res
      }
    };
    const response = await handler(context);
    if (passThroughCalled) {
      next == null ? void 0 : next();
      return;
    }
    const body = response.body instanceof Readable ? response.body : response.body instanceof ReadableStream && typeof Readable.fromWeb === "function" ? Readable.fromWeb(response.body) : response.body ? Readable.from(response.body) : null;
    res.statusCode = response.status;
    for (const [key, value] of response.headers) {
      if (key === "set-cookie") {
        const setCookie = response.headers.getSetCookie();
        res.setHeader("set-cookie", setCookie);
      } else {
        res.setHeader(key, value);
      }
    }
    if (body) {
      body.pipe(res, { end: true });
      await Promise.race([once(res, "finish"), once(res, "error")]).catch(
        () => {
        }
      );
    } else {
      res.setHeader("content-length", "0");
      res.end();
    }
    if (next && alwaysCallNext) {
      next();
    }
  };
}
function createServer(handler, adapterOptions, serverOptions) {
  const listener = createMiddleware(handler, adapterOptions);
  return serverOptions ? createHttpServer(serverOptions, listener) : createHttpServer(listener);
}

export {
  createMiddleware,
  createServer
};
