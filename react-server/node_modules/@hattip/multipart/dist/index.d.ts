interface MultipartPart {
    headers: SimpleHeaders;
    body: ReadableStream<Uint8Array>;
}
type SimpleHeaders = Map<string, string>;

interface MultipartParserOptions {
    /** Boundary text */
    boundaryText: string;
    /** Create the error to throw when a limit is exceeded */
    createLimitError?(name: string, value: number, limit: number): Error;
    /** The maximum number of headers @default 16 */
    maxHeaderCount?: number;
    /** The maximum size of a header in bytes @default 1024 */
    maxHeaderSize?: number;
    /** The maximum combined size of all headers in bytes @default 4096 (4K) */
    maxTotalHeaderSize?: number;
    /** The maximum number of parts @default 1024 */
    maxParts?: number;
}
declare function parseMultipart(input: ReadableStream<Uint8Array>, options: MultipartParserOptions): AsyncIterableIterator<MultipartPart>;

interface FormDataParserOptions<F> {
    /**
     * File handler.
     *
     * It's called for each file part and should return a promise that resolves
     * to a file value. The file value is a platform-specific representation of
     * the file. It should be something other than a string so that it can be
     * distinguished from a string field value. For example, it could be an
     * object with a `path` property that points to a temporary file on disk.
     */
    handleFile: FileHandler<F>;
    /** Create the error to throw when a limit is exceeded */
    createLimitError?(name: string, value: number, limit: number): Error;
    /**
     * Create the error to throw when the Content-Type header is not multipart
     * form-data with a boundary.
     */
    createTypeError?(): Error;
    /**
     * Create the error to throw when the Content-Disposition header is
     * invalid. */
    createContentDispositionError?(): Error;
    /** The maximum number of headers @default 16 */
    maxHeaderCount?: number;
    /** The maximum size of a header in bytes @default 1024 */
    maxHeaderSize?: number;
    /** The maximum combined size of all headers in bytes @default 4096 (4K) */
    maxTotalHeaderSize?: number;
    /** The maximum number of parts (approximately equal to maximum number of fields) @default 1024 */
    maxParts?: number;
    /** The maximum size of a single text field value in bytes @default 65536 (64K) */
    maxTextFieldSize?: number;
    /** The maximum combined size of all text field values in bytes @default 1048576 (1M) */
    maxTotalTextFieldSize?: number;
    /** The maximum number of files @default 16 */
    maxFileCount?: number;
    /** The maximum filename length @default 128 */
    maxFilenameLength?: number;
    /** The maximum size of a single file in bytes @default 4194304 (4M) */
    maxFileSize?: number;
    /** The maximum combined size of all files in bytes @default 16777216 (16M) */
    maxTotalFileSize?: number;
}
declare function parseMultipartFormData<F>(request: Request, options: FormDataParserOptions<F>): Promise<MultipartFormData<Awaited<F>>>;
declare class MultipartFormData<F> {
    private _fields;
    constructor(fields: Array<[string, string | F]>);
    get(name: string): string | F | null;
    getAll(name: string): Array<string | F>;
    has(name: string): boolean;
    forEach(callback: (value: string | F, name: string, parent: MultipartFormData<F>) => void): void;
    entries(): IterableIterator<[string, string | F]>;
    keys(): IterableIterator<string>;
    values(): IterableIterator<string | F>;
    [Symbol.iterator](): IterableIterator<[string, string | F]>;
}
type FileHandler<F> = (fileInfo: FileInfo) => F;
type Awaited<T> = T extends Promise<infer U> ? Awaited<U> : T;
interface FileInfo {
    /** Name of the field that contains the file */
    name: string;
    /** The name of the file, sanitized */
    filename: string;
    /** The unsanitized name of the file as sent by the client */
    unsanitizedFilename: string;
    /**
     * The content type of the file as sent by the client.
     *
     * Defaults to `application/octet-stream`
     */
    contentType: string;
    /**
     * File content as a readable stream.
     *
     * You have to consume the stream before the next `FileHandler` callback
     * called. Otherwise the it will be consumed when you return. You can't
     * save the stream and consume it later.
     */
    body: ReadableStream<Uint8Array>;
}

export { FileHandler, FileInfo, FormDataParserOptions, MultipartFormData, MultipartParserOptions, MultipartPart as Part, parseMultipart, parseMultipartFormData };
