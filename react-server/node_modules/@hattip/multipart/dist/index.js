// src/limits.ts
var DEFAULT_MAX_HEADER_COUNT = 16;
var DEFAULT_MAX_HEADER_SIZE = 1024;
var DEFAULT_MAX_TOTAL_HEADER_SIZE = 4 * 1024;
var DEFAULT_MAX_PARTS = 1024;
var DEFAULT_MAX_TEXT_FIELD_SIZE = 64 * 1024;
var DEFAULT_MAX_TOTAL_TEXT_FIELD_SIZE = 1024 * 1024;
var DEFAULT_MAX_FILENAME_LENGTH = 128;
var DEFAULT_MAX_FILE_SIZE = 4 * 1024 * 1024;
var DEFAULT_MAX_TOTAL_FILE_SIZE = 16 * 1024 * 1024;
function defaultCreateLimitError(name, value, limit) {
  return new Error(`${name} exceeded limit of ${limit} bytes: ${value}`);
}

// src/split.ts
function split(input, boundary, boundaryRep) {
  let leftovers = 0;
  const transform = new TransformStream({
    transform(chunk, controller) {
      let afterBoundary = leftovers ? boundary.length - leftovers : 0;
      if (leftovers) {
        for (let i = 0; i < boundary.length - leftovers; i++) {
          if (i >= chunk.length) {
            leftovers += i;
            return;
          }
          if (chunk[i] !== boundary[leftovers + i]) {
            afterBoundary = 0;
            break;
          }
        }
        if (afterBoundary) {
          controller.enqueue(boundaryRep);
        } else {
          controller.enqueue(boundary.slice(0, leftovers));
        }
        leftovers = 0;
      }
      while (afterBoundary < chunk.length) {
        const index = findPartial(chunk, boundary, afterBoundary);
        if (index >= 0 && index <= chunk.length - boundary.length) {
          if (index > 0) {
            controller.enqueue(chunk.slice(afterBoundary, index));
          }
          controller.enqueue(boundaryRep);
          afterBoundary = index + boundary.length;
        } else if (index >= 0) {
          leftovers = chunk.length - index;
          controller.enqueue(
            chunk.slice(afterBoundary, chunk.length - leftovers)
          );
          break;
        } else {
          controller.enqueue(chunk.slice(afterBoundary));
          break;
        }
      }
    }
  });
  return input.pipeThrough(transform);
}
function findPartial(array, slice, offset) {
  let i = offset;
  outer:
    for (i = array.indexOf(slice[0], i); i >= 0; i = array.indexOf(slice[0], i + 1)) {
      for (let j = 0; j < slice.length; j++) {
        const value = array[i + j];
        if (value === void 0) {
          return i;
        } else if (value !== slice[j]) {
          continue outer;
        }
      }
      return i;
    }
  return -1;
}

// src/multipart.ts
async function* parseMultipart(input, options) {
  const completeOptions = {
    ...options,
    createLimitError: options.createLimitError ?? defaultCreateLimitError,
    maxHeaderCount: options.maxHeaderCount ?? DEFAULT_MAX_HEADER_COUNT,
    maxHeaderSize: options.maxHeaderSize ?? DEFAULT_MAX_HEADER_SIZE,
    maxTotalHeaderSize: options.maxTotalHeaderSize ?? DEFAULT_MAX_TOTAL_HEADER_SIZE,
    maxParts: options.maxParts ?? DEFAULT_MAX_PARTS
  };
  const stream = parsePartHeaders(input, completeOptions);
  let nextHeaders;
  const reader = stream.getReader();
  function body() {
    return new ReadableStream({
      async pull(controller) {
        try {
          const { done, value } = await reader.read();
          if (done) {
            controller.close();
            return;
          }
          if (value instanceof Map) {
            nextHeaders = value;
            controller.close();
            return;
          }
          controller.enqueue(value);
        } catch (error) {
          controller.error(error);
        }
      }
    });
  }
  for (; ; ) {
    let next;
    if (nextHeaders) {
      next = { value: nextHeaders, done: false };
      nextHeaders = void 0;
    } else {
      next = await reader.read();
    }
    while (!next.done && !(next.value instanceof Map)) {
      next = await reader.read();
    }
    if (next.done) {
      break;
    }
    const part = {
      headers: next.value,
      body: body()
    };
    yield part;
    try {
      const reader2 = await part.body.getReader();
      for (; ; ) {
        const { done } = await reader2.read();
        if (done) {
          break;
        }
      }
    } catch {
    }
  }
}
function parsePartHeaders(input, options) {
  let totalParts = 0;
  let totalHeaderSize = 0;
  let state = "header";
  let crLfState = "none";
  let headers = /* @__PURE__ */ new Map();
  let headerCount = 0;
  const lastHeader = new Uint8Array(options.maxHeaderSize);
  let lastHeaderOffset = 0;
  const stack = [];
  const parts = trimTrailingCrLf(input, options.boundaryText);
  const reader = parts.getReader();
  return new ReadableStream({
    async pull(controller) {
      try {
        let enqueued = false;
        do {
          let part;
          if (stack.length) {
            part = stack.pop();
          } else {
            const next = await reader.read();
            if (next.done) {
              controller.close();
              return;
            }
            part = next.value;
          }
          if (part === "part-boundary") {
            totalParts++;
            if (totalParts > options.maxParts) {
              throw options.createLimitError(
                "maxParts",
                totalParts,
                options.maxParts
              );
            }
            if (state === "header") {
              controller.enqueue(headers);
              enqueued = true;
              headers = /* @__PURE__ */ new Map();
              headerCount = 0;
              lastHeaderOffset = 0;
              crLfState = "none";
            } else {
              state = "header";
            }
          } else if (state === "header") {
            loop:
              for (let i = 0; i < part.length; i++) {
                if (crLfState === "none") {
                  const crPos = part.indexOf(13, i);
                  if (crPos === -1) {
                    lastHeader.set(part.slice(i), lastHeaderOffset);
                    lastHeaderOffset += part.length - i;
                    break;
                  } else {
                    lastHeader.set(part.slice(i, crPos), lastHeaderOffset);
                    lastHeaderOffset += crPos - i;
                    i = crPos;
                  }
                }
                const byte = part[i];
                switch (crLfState) {
                  case "none":
                    if (byte === 13) {
                      crLfState = "cr";
                    }
                    break;
                  case "cr":
                    if (byte === 10) {
                      crLfState = "cr-lf";
                      const lastHeaderText = new TextDecoder().decode(
                        lastHeader.slice(0, lastHeaderOffset - 1)
                      );
                      const [name, value] = lastHeaderText.split(": ", 2);
                      append(headers, name.toLowerCase(), value.trim());
                      headerCount++;
                      if (headerCount >= options.maxHeaderCount) {
                        throw options.createLimitError(
                          "maxHeaderCount",
                          headerCount,
                          options.maxHeaderCount
                        );
                      }
                      lastHeaderOffset = 0;
                      continue;
                    } else {
                      crLfState = "none";
                    }
                    break;
                  case "cr-lf":
                    if (byte === 13) {
                      crLfState = "cr-lf-cr";
                    } else {
                      crLfState = "none";
                    }
                    break;
                  case "cr-lf-cr":
                    if (byte === 10) {
                      controller.enqueue(headers);
                      enqueued = true;
                      crLfState = "none";
                      state = "body";
                      headers = /* @__PURE__ */ new Map();
                      headerCount = 0;
                      lastHeaderOffset = 0;
                      if (i + 1 < part.length) {
                        stack.push(part.slice(i + 1));
                      }
                      break loop;
                    }
                }
                lastHeader[lastHeaderOffset++] = byte;
                if (lastHeaderOffset === lastHeader.length) {
                  throw options.createLimitError(
                    "maxHeaderSize",
                    lastHeaderOffset,
                    options.maxHeaderSize
                  );
                }
                totalHeaderSize++;
                if (totalHeaderSize > options.maxTotalHeaderSize) {
                  throw options.createLimitError(
                    "maxTotalHeaderSize",
                    totalHeaderSize,
                    options.maxTotalHeaderSize
                  );
                }
              }
          } else if (part.length) {
            controller.enqueue(part);
            enqueued = true;
          }
        } while (!enqueued);
      } catch (err) {
        controller.error(err);
      }
    }
  });
}
function trimTrailingCrLf(input, boundaryText) {
  const buffered = [];
  let state = "none";
  const transform = new TransformStream({
    transform(chunk, controller) {
      if (chunk !== "part-boundary") {
        if (!chunk.length) {
          return;
        }
        if (chunk.length === 1) {
          if (chunk[0] === 13) {
            for (const oldChunk of buffered) {
              controller.enqueue(oldChunk);
            }
            state = "cr";
            buffered.length = 0;
            buffered.push(chunk);
          } else if (state === "cr" && chunk[0] === 10) {
            state = "crlf";
            buffered.push(chunk);
          } else {
            for (const oldChunk of buffered) {
              controller.enqueue(oldChunk);
            }
            controller.enqueue(chunk);
            state = "none";
            buffered.length = 0;
          }
        } else {
          if (chunk[chunk.length - 1] === 13) {
            state = "cr";
            buffered.push(chunk);
          } else if (chunk[chunk.length - 1] === 10 && chunk[chunk.length - 2] === 13) {
            state = "crlf";
            buffered.push(chunk);
          } else {
            for (const oldChunk of buffered) {
              controller.enqueue(oldChunk);
            }
            controller.enqueue(chunk);
            buffered.length = 0;
            state = "none";
          }
        }
      } else {
        if (state === "crlf") {
          if (buffered[buffered.length - 1].length === 1) {
            buffered.pop();
            if (buffered[buffered.length - 1].length === 1) {
              buffered.pop();
            } else {
              buffered[buffered.length - 1] = buffered[buffered.length - 1].slice(0, buffered[buffered.length - 1].length - 1);
            }
          } else {
            buffered[buffered.length - 1] = buffered[buffered.length - 1].slice(
              0,
              buffered[buffered.length - 1].length - 2
            );
          }
          for (const oldChunk of buffered) {
            controller.enqueue(oldChunk);
          }
        }
        controller.enqueue("part-boundary");
        state = "none";
        buffered.length = 0;
      }
    }
  });
  return splitMultipart(input, boundaryText).pipeThrough(transform);
}
function splitMultipart(input, boundaryText) {
  const boundary = new TextEncoder().encode("--" + boundaryText);
  let partNo = 0;
  let state = "none";
  const transform = new TransformStream({
    transform(chunk, controller) {
      if (state === "ended")
        return;
      let start = 0;
      if (partNo === 0 && chunk !== "part-boundary") {
        return;
      } else if (chunk === "part-boundary") {
        if (partNo)
          controller.enqueue("part-boundary");
        partNo++;
        state = "skip-space";
        return;
      }
      if (state === "skip-space") {
        if (start < chunk.length && chunk[start] === 45) {
          state = "dash1";
          start++;
        } else {
          while (start < chunk.length && (chunk[start] === 32 || chunk[start] === 9)) {
            start++;
          }
          if (start < chunk.length) {
            state = "skip-cr";
          }
        }
      }
      if (state === "dash1") {
        if (chunk[start] === 45) {
          state = "ended";
          return;
        }
        if (start === chunk.length) {
          state = "ended";
          return;
        }
        controller.enqueue(new Uint8Array([45]));
        state = "none";
      }
      if (state === "skip-cr") {
        if (start < chunk.length && chunk[start] === 13) {
          start++;
          state = "skip-lf";
        } else if (start < chunk.length) {
          state = "none";
        }
      }
      if (state === "skip-lf") {
        if (start < chunk.length && chunk[start] === 10) {
          start++;
          state = "none";
        } else if (start < chunk.length) {
          state = "none";
        }
      }
      if (state === "none") {
        controller.enqueue(chunk.slice(start));
      }
    }
  });
  return split(input, boundary, "part-boundary").pipeThrough(transform);
}
function append(headers, key, value) {
  const existing = headers.get(key);
  if (existing) {
    headers.set(key, existing + ", " + value);
  }
  headers.set(key, value);
}

// src/form-data.ts
import { parseHeaderValue } from "@hattip/headers";
async function parseMultipartFormData(request, options) {
  const contentType = request.headers.get("content-type");
  const createTypeError = options.createTypeError || (() => new Error("Invalid content type"));
  const createContentDispositionError = options.createContentDispositionError || (() => new Error("Invalid content disposition"));
  const createLimitError = options.createLimitError || defaultCreateLimitError;
  let totalFileSize = 0;
  const {
    maxFileSize = DEFAULT_MAX_FILE_SIZE,
    maxTotalFileSize = DEFAULT_MAX_TOTAL_FILE_SIZE
  } = options;
  const match = parseHeaderValue(contentType || "")[0];
  if (!match || match.value !== "multipart/form-data" || !match.directives.boundary) {
    throw createTypeError();
  }
  if (!request.body) {
    return new MultipartFormData([]);
  }
  const parts = parseMultipart(request.body, {
    boundaryText: match.directives.boundary,
    maxHeaderSize: options.maxHeaderSize,
    maxHeaderCount: options.maxHeaderCount,
    maxParts: options.maxParts
  });
  const fields = [];
  for await (const part of parts) {
    const headerValue = part.headers.get("content-disposition");
    if (!headerValue) {
      continue;
    }
    const { name, filename } = parseContentDisposition(
      headerValue,
      createContentDispositionError
    );
    if (!name) {
      continue;
    }
    if (filename) {
      const sanitized = sanitizeFileName(
        filename,
        options.maxFilenameLength ?? DEFAULT_MAX_FILENAME_LENGTH
      );
      let size = 0;
      const limiter = new TransformStream({
        transform(chunk, controller) {
          size += chunk.byteLength;
          if (size > maxFileSize) {
            controller.error(
              createLimitError("maxFileSize", size, maxFileSize)
            );
            return;
          }
          totalFileSize += chunk.byteLength;
          if (totalFileSize > maxTotalFileSize) {
            controller.error(
              createLimitError(
                "maxTotalFileSize",
                totalFileSize,
                maxTotalFileSize
              )
            );
            return;
          }
          controller.enqueue(chunk);
        }
      });
      const file = await options.handleFile({
        name,
        filename: sanitized,
        unsanitizedFilename: filename,
        contentType: part.headers.get("content-type") || "application/octet-stream",
        body: part.body.pipeThrough(limiter)
      });
      fields.push([name, file]);
    } else {
      fields.push([
        name,
        await readPartBody(
          part.body,
          options.maxTextFieldSize ?? DEFAULT_MAX_TEXT_FIELD_SIZE,
          createLimitError
        )
      ]);
    }
  }
  return new MultipartFormData(fields);
}
var MultipartFormData = class {
  constructor(fields) {
    this._fields = fields;
  }
  get(name) {
    var _a;
    return ((_a = this._fields.find(([fieldName]) => fieldName === name)) == null ? void 0 : _a[1]) ?? null;
  }
  getAll(name) {
    return this._fields.filter(([fieldName]) => fieldName === name).map(([, value]) => value);
  }
  has(name) {
    return this._fields.some(([fieldName]) => fieldName === name);
  }
  forEach(callback) {
    this._fields.forEach(([name, value]) => callback(value, name, this));
  }
  *entries() {
    yield* this._fields;
  }
  *keys() {
    yield* this._fields.map(([name]) => name);
  }
  *values() {
    yield* this._fields.map(([, value]) => value);
  }
  [Symbol.iterator]() {
    return this.entries();
  }
};
async function readPartBody(body, maxSize, createLimitError) {
  const decoder = new TextDecoder();
  let result = "";
  let size = 0;
  const reader = body.getReader();
  for (; ; ) {
    const { value, done } = await reader.read();
    if (done) {
      break;
    }
    size += value.byteLength;
    if (size > maxSize) {
      throw createLimitError("maxTextFieldSize", size, maxSize);
    }
    result += decoder.decode(value, { stream: true });
  }
  decoder.decode();
  return result;
}
function parseContentDisposition(value, createError) {
  const parsed = parseHeaderValue(value)[0];
  if ((parsed == null ? void 0 : parsed.value) !== "form-data") {
    throw createError();
  }
  const { name, filename } = parsed.directives;
  return { name, filename };
}
function sanitizeFileName(filename, max) {
  filename = filename.replace(/[\0-\x1f\x80-\xff]+/g, " ").replace(/[/\\?<>:*|"]/g, "_").replace(/[ .]+$/, "");
  if (filename.length > max) {
    filename = filename.slice(0, max);
  }
  if (RESERVED_FILE_NAMES.has(filename.toUpperCase())) {
    filename += "_";
  } else {
    filename = REPLACEMENT_NAMES[filename] ?? filename;
  }
  return filename;
}
var RESERVED_FILE_NAMES = /* @__PURE__ */ new Set([
  "CON",
  "PRN",
  "AUX",
  "NUL",
  "COM1",
  "COM2",
  "COM3",
  "COM4",
  "COM5",
  "COM6",
  "COM7",
  "COM8",
  "COM9",
  "LPT1",
  "LPT2",
  "LPT3",
  "LPT4",
  "LPT5",
  "LPT6",
  "LPT7",
  "LPT8",
  "LPT9"
]);
var REPLACEMENT_NAMES = {
  "": "_",
  ".": "dot",
  "..": "dotdot"
};
export {
  parseMultipart,
  parseMultipartFormData
};
